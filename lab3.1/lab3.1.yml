# SI413 Lab 3.1: Spec and interpreter for iffy language

your_name: George Prielipp

your_alpha: 265112

used_ai: N # remember to turn in an aichat.md file as well

# leave this as NONE for your initial submission
changes_on_resubmit: |
    NONE

# describe any collaboration or help you got from classmates
collaboration: |
    NONE

# come up with an original name for your new langauge - extending truffle
language_name: choco

# explain a little what inspired your language and why it's cool
language_explanation: |
    Truffle chocolates are named after truffle mushrooms because they look similar. But that is where it stops.
    As such, since I am extending truffle, it will look like truffle, but they will be inherently different in their abilities.

# this is the example program that you make up
example_program: |
    p [Enter your name:]
    s.name~i
    ? ([Bill]:s.name)  { p (s.name + [ is a good name]) }

    p [Guess a color]
    s.color ~ [red]
    s.guess ~ i
    while (r ((s.guess:s.color) & (s.color:s.guess)) ) do {
    ? (s.guess < s.color) {
        p [Your guess is less than the color]
    } ; {
        ? (s.guess > s.color) {
        p [Your guess is greater than the color]
        }
    } 

    ? (r ((s.guess:s.color) & (s.color:s.guess))) { s.guess~i }
    }
    p [You guessed correct!]

example_input_1: |
    Bill
    blue
    red

example_output_1: |
    Enter your name:
    Bill is a good name
    Guess a color
    Your guess is less than the color
    You guessed correct!


example_input_2: |
    George
    blue
    green
    yellow
    red

example_output_2: |
    Enter your name:
    Guess a color
    Your guess is less than the color
    Your guess is less than the color
    Your guess is greater than the color
    You guessed correct!


# your implementation of the "dance" program in your language
dance_program: |
    p [enter two dance moves]
    s.x ~ i + [m] + i
    p [Let's do the ] + s.x
    b.y ~ [mb]:s.x
    ? (s.x < [mambo]) {
        p r s.x
        b.y ~ 0
    }
    p b.y
    p ([a]:s.x & r b.y)
    s.timer~[]
    while (r ([...]:s.timer)) do {
        p [cha]
        s.timer ~ s.timer + [.]
    }

# something else your instructor should know?
any_other_comments_for_me: |
    NONE
